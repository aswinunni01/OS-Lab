// Exception handler

[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1]*16 + 9] = -1;
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE +1]*16 + 13] = SP;
SP = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE +1]*16 + 11]*512 - 1;

backup;



alias userSP R1; 
userSP = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE +1]*16 + 13];
alias currentPID R2;
currentPID = [SYSTEM_STATUS_TABLE + 5*CORE +1];
multipush(EIP);

multipush(R1, R2, EC, EIP, EPN);
R1 = ACQUIRE_KERN_LOCK;
call ACCESS_CONTROL;
multipop(R1, R2, EC, EIP, EPN);

if((EC != 0) || (userSP == (PTLR*512) -1)) then
	print "Fatal exc";
        print R2;
	print EC;
	print EMA;
	print EIP;
	multipush(R1, R2);
	R1 = 3;
	R2 = currentPID;
	call MOD_1;
	R1 = RELEASE_LOCK;
	R2 = KERN_LOCK;
	call ACCESS_CONTROL;
	call MOD_5;
	R1 = ACQUIRE_KERN_LOCK;
	call ACCESS_CONTROL;
	multipop(R1, R2);
endif;
alias blockNum R3;
if((EPN >3)&& (EPN < 8)) then // code page
	blockNum = [DISK_MAP_TABLE + currentPID*10 + EPN];
	multipush(R1, R2, R3, EPN);
	R1 = 5;
	R2 = blockNum;
	call MOD_2;
	multipop(R1, R2, R3, EPN);
	[PTBR + 2*EPN] = R0;
	[PTBR + 2*EPN + 1] = "1100";
endif;

if(EPN >1 && EPN < 4) then
	multipush(R1, R2, R3);
	R1 = 1;
	call MOD_2;
	[PTBR + 4] = R0;
	[PTBR + 4 + 1] = "1110";
	R1 = 1;
        call MOD_2;
        [PTBR + 6] = R0;
        [PTBR + 6 + 1] = "1110";
	multipop(R1, R2, R3);
endif;

multipush(R2);
R1 = RELEASE_LOCK;
R2 = KERN_LOCK;
call ACCESS_CONTROL;
multipop(R2);

[PROCESS_TABLE + currentPID * 16 + 9] = 0;
multipop(EIP);
restore;
SP = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1]*16 + 13];
SP = SP + 1;
[[PTBR + 2*(SP / 512)]*512 + (SP %512)] = EIP;
ireturn;



